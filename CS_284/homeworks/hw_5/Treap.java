/**
 * @author Ming Lin
 * 
 * I pledge my honor that I have abided by the Stevens Honor Code.
 */

package homeworks.hw_5;
import java.util.*;

public class Treap<E extends Comparable<E>>{
  
  public static class Node<E> {

    // Node Data fields 
    public E data; // key for the search
    public int priority; //random heap priority
    public Node<E> left;
    public Node<E> right;

    // Node Constructors

    /**
     * Creates a new node with the given data and priority. The pointers to child
     * nodes are null. Throw exceptions if data is null.
     */
    public Node(E data, int priority) {
      if (data == null) {
        throw new IllegalArgumentException("Node requires data");
      }

      this.data = data;
      this.priority = priority;
      this.left = null;
      this.right = null;
    }
    
    /**
     * This method performs a right rotation, returning a reference to the root of
     * the result. The root node in the figure corresponds to this node. Update the
     * data and priority attributes as well as the left and right pointers of the
     * involved nodes accordingly.
     */
    public Node<E> rotateRight() {
      Node<E> head = this.left;
      Node<E> left = head.right;
      this.left = left;
      head.right = this;
      return head;
    }

    /**
     * This method performs a left rotation, returning a reference to the root of the
     * result. The root node in the figure corresponds to this node. Update the data
     * and priority attributes as well as the left and right pointers of the
     * involved nodes accordingly.
     */
    public Node<E> rotateLeft() {
      Node<E> head = this.right;
      Node<E> right = head.left;
      this.right = right;
      head.left = this;
      return head;
    }
  }

  // Treap Data fields
  private Random priorityGenerator;
  private Node<E> root;

  // Treap Constructors

  /**
   * Constructor that creates an empty treap
   */
  public Treap() {
    priorityGenerator = new Random();
    root = null;
  }

  /**
   * Constructor that creates an empty treap and initializes 
   * priorityGenerator using newRandom(seed).
   */
  public Treap(long seed) {
    priorityGenerator = new Random(seed);
    root = null;
  }

  /**
   * This method inserts the given element into the treap, create a new node
   * containing key as its data and a random priority generated by
   * priorityGenerator. The method returns true, if a node with the key was
   * successfully added to the treap. If there is already a node containing the
   * given key, the method returns false and does not modify the treap
   */
  public boolean add(E key) {
    // call add(E key, int priority) with randomly generated priority
    return add(key, priorityGenerator.nextInt());
  }

  public boolean add(E key, int priority) {
    // empty state: a empty treap
    if (this.root == null) {
      // set root as the new Node
      this.root = new Node<E>(key, priority);
      return true;
    } else {
      // initialize new Node
      Node<E> newNode = new Node<E>(key, priority);
      // initialize Stack to storing each node in the path from the root until the
      // spot where the new node will be inserted
      Stack<Node<E>> stack = new Stack<Node<E>>();
      Node<E> currentNode = root;

      // traverse treap
      while (currentNode != null) {
        // If there is already a node containing the given key, the method
        // returns false and does not modify the treap
        if (currentNode.data.compareTo(key) == 0) {
          return false;
        } else { // The method returns true, if a node with the key was successfully added to the treap
        
          if (currentNode.data.compareTo(key) < 0) {
            // push currentNode to stack to bubble up the new node in the tree 
            // towards the root according to the priorities of the currentNode
            stack.push(currentNode);

            // traverse through right child
            if (currentNode.right == null) {
              currentNode.right = newNode;
              reheap(newNode, stack);
              return true;
            } else {
              currentNode = currentNode.right;
            }

          } else {
            stack.push(currentNode);

            // traverse through left child 
            if (currentNode.left == null) {
              currentNode.left = newNode;
              reheap(newNode, stack);
              return true;
            } else {
              currentNode = currentNode.left;
            }
          }

        }
      }
      return false;
    }
  }

  /**
   * deletes the node with the given key from the treap and returns true. If the key
   * was not found, the method does not modify the treap and returns false
   */
  public boolean delete(E key) {
    // if the key was not found, the method does not modify the treap and returns false
    if (root == null || find(key) == false) {
      return false;
    } else {
      //
      root = deleteUtil(key, root);
      return true;
    }
  }
  
  /**
   * This method removes a node by trickling it down using rotation until it becomes a
   * leaf and then remove it.
   */
  private Node<E> deleteUtil(E key, Node<E> currentNode) {
    // base case
    if (currentNode == null) {
      return currentNode;
    } else {

      // When trickling down sometimes you will have to rotate left and sometimes
      // right
      if (currentNode.data.compareTo(key) < 0) {
        currentNode.right = deleteUtil(key, currentNode.right);
      } else {
        if (currentNode.data.compareTo(key) > 0) {
          currentNode.left = deleteUtil(key, currentNode.left);
        } else {
          // if there is no right subtree of the node to delete, rotate left
          if (currentNode.right == null) {
            currentNode = currentNode.left;
          // if there is no left subtree of the node to delete, rotate right
          } else if (currentNode.left == null) {
            currentNode = currentNode.right;
          } else {
            // if the node to erase has both then you have to look at the priorities of the
            // children and consider the highest one to determine whether you have to rotate
            // to the left or the right.
            if (currentNode.right.priority < currentNode.left.priority) {
              currentNode = currentNode.rotateRight();
              currentNode.right = deleteUtil(key, currentNode.right);
            } else {
              currentNode = currentNode.rotateLeft();
              currentNode.left = deleteUtil(key, currentNode.left);
            }
          }
        }
      }

    }
    return currentNode;
  }

  /**
   * Finds a node with the given key in the treap rooted at root and returns true if
   * it finds it and false otherwise
   */
  private boolean find(Node<E> currentNode, E key) {
    // base case
    if (currentNode == null) {
      return false;
    } else {
      // if currentNode exists
      if (currentNode.data.compareTo(key) == 0) {
        return true;
      } else {
        return find(currentNode.left, key) || find(currentNode.right, key);
      }
    }
  }
  
  /**
   * Finds a node with the given key in the treap and returns true if it finds it
   * and false otherwise
   */
  public boolean find(E key) {
    return find(root, key);
  }

  /**
   * this method restores the heap invariant
   */
  public void reheap(Node<E> currentNode, Stack<Node<E>> stack) {
    while (!stack.isEmpty()) {
      Node<E> parent = stack.pop();
      if (parent.priority < currentNode.priority) {
        if (parent.data.compareTo(currentNode.data) > 0) {
          currentNode = parent.rotateRight();
        } else {
          currentNode = parent.rotateLeft();
        }
        if (!stack.isEmpty()) {
          if (stack.peek().left == parent) {
            stack.peek().left = currentNode;
          } else {
            stack.peek().right = currentNode;
          }
        } else {
          this.root = currentNode;
        }
      } else {
        break;
      }
    }
  }

  public String toString() {
    return toStringUtil(root, 0);
  }

  /**
   * Carries out a preorder traversal(root, left, right) of the tree and returns a representation of
   * the nodes as a string
   */
  private String toStringUtil(Node<E> currentNode, int height) {
    StringBuilder string = new StringBuilder();
    for (int i = 0; i < height; i++) {
      string.append("--");
    }

    // if currentNode does not exist
    if (currentNode == null) {
      string.append("null");
    } else {
      string.append("(key = " + currentNode.data + ", priority = " + currentNode.priority + ")");
      string.append("\n");
      string.append(toStringUtil(currentNode.left, height + 1));
      string.append("\n");
      string.append(toStringUtil(currentNode.right, height + 1));
    }

    return string.toString();
  }

  public static void main(String[] args) {
    Treap<Integer> testTree = new Treap<Integer>();
    testTree.add (4 ,19);
    testTree.add (2 ,31);
    testTree.add (6 ,70);
    testTree.add(1, 84);
    testTree.add(3, 12);
    testTree.add (5 ,83);
    testTree.add(7, 26);
    
    //(key = 1, priority = 84)
    //--null
    //--(key = 5, priority = 83)
    //----(key = 2, priority = 31)
    //------null
    //------(key = 4, priority = 19)
    //--------(key = 3, priority = 12)
    //----------null
    //----------null
    //--------null
    //----(key = 6, priority = 70)
    //------null
    //------(key = 7, priority = 26)
    //--------null
    //--------null

    System.out.println(testTree.toString());

    System.out.println("testTree.find(83)");
    System.out.println(testTree.find(83));
    System.out.println("testTree.find(100)");
    System.out.println(testTree.find(100));
    System.out.println("testTree.find(1)");
    System.out.println(testTree.find(1));
    System.out.println("testTree.find(2)");
    System.out.println(testTree.find(2));

    System.out.println("testTree.delete(83)");
    System.out.println(testTree.delete(83));
    System.out.println("testTree.delete(100)");
    System.out.println(testTree.delete(100));
    System.out.println("testTree.delete(1)");
    System.out.println(testTree.delete(1));
    System.out.println("testTree.delete(2)");
    System.out.println(testTree.delete(2));
  }
}
